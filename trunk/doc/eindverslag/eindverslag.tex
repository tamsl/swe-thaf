\documentclass[a4paper,10pt]{article}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage{hyperref}
\usepackage{cite}
\usepackage[dutch]{babel}

\title{Software Engineering en Gedistribueerde Applicaties \\[10pt]Eindverslag\\[25pt]Team F.A.C.H.T.}
\author{\\Chris Bovenschen, Harm Dermois, \\Alexandra Moraga Pizarro, Tamara Ockhuijsen en Fredo Tan \\[10pt]6104096, 0527963, 6129544, 6060374, 6132421 \\[25pt]Universiteit van Amsterdam}
\begin{document}
\maketitle

\newpage
\tableofcontents

\newpage
\section{Inleiding}
Dit verslag beschrijft het ontwerpen, implementeren en testen van een gedistribueerde robotapplicatie. De robot die hiervoor wordt gebruikt, is de gesimuleerde P2DX. Deze heeft twee aangedreven wielen en een zwenkwiel. Het platform voor de robotsimulatie is USARSim. Het doel is om met behulp van de sensoren op de robot in een vrij volle ruimte de volgende acties uit te kunnen voeren:
\begin{itemize}
  \item een pad langs een wand te rijden
  \item botsingen te vermijden
  \item zonodig een wand op te zoeken
  \item uit doodlopende stukken te ontsnappen
  \item bijhouden waar hij is en welk pad hij heeft gevolgd
  \item de omgeving in kaart te brengen
\end{itemize}
Het project is op te delen in verschillende fases. Aan het begin is er nagedacht over een ontwerp met een model, een planning en een specificatie van het eindproduct. Hieruit is een voorlopig werkplan ontstaan. In het definitieve werkplan is een uitgebreidere beschrijving van de realisatie van verschillende componenten met bijbehorende tests te vinden samen met de eerste inleverbare versie van de code. Het grootste deel van de tijd heeft gezeten in de implementatie en tests. Als laatst zijn de componenten ge\"{i}ntegreerd tot een geheel, getest en geoptimaliseerd.

Dit verslag behandelt eerst de implementatie van de componenten met de bijbehorende tests en de opzet van het experiment. Daarna worden de resultaten besproken en hieruit volgt een conclusie.

\newpage

\section{Implementatie}
De modules zijn verdeeld in low-level, sensor, mid-level en high-level componenten. De listener is een low-level component, de sonar, laser en odometry zijn sensormodules, de wall search, wall follow en collision avoider zijn mid-level componenten en de map maker en path finding zijn high-level componenten. De movements en communicator zijn libraries die door andere modules kunnen worden gebruikt. 

De listener is verbonden met de server via een TCP-verbinding en stuurt de data direct door naar de sensormodules. De sensormodules halen de juiste waarden uit de data die voor hun bestemd zijn en sturen deze door naar de mid-level modules, de map maker en path finding. Berekende kaarten van de map maker kunnen worden gebruikt voor de path finding. Path finding gebruikt de movements library om het pad te kunnen volgen. Als de robot aan het rijden is, staat de collision avoider te alle tijde aan.

\subsection{Low-level}
De low-level component verkrijgt rechtstreeks data van de robot en stuurt de ontvangen data van de robot direct door naar de sensormodules.

\subsubsection{Listener}
De listener zit direct aan de server vast. Hij haalt informatie binnen die de robot verstuurt en stuurt ook commando's naar de robot toe. De binnenkomende data worden meteen doorgestuurd naar de sensormodules. Eerst controleerde de listener de data ook op geldigheid en stuurde deze in het juiste formaat door naar de bijbehorende sensormodules. Echter werd de listener overwelmd door de data, waardoor deze nu slechts een doorgever is geworden.

Zie appendix \ref{listener}

\subsection{Sensormodules}
De sensormodules ontvangen data van de listener. Ze kijken of de data voor hun bestemd zijn en anders negeren ze deze. Ze verkrijgen de sensorwaarden uit de data en kunnen worden aangeroepen voor de meest recente data. Zodra er ongeldige data binnenkomen, wordt de robot gestopt.

\subsubsection{Odometry}
Odometry haalt de drie waarden op die nodig zijn voor de bepaling van de positie van de robot. Dit zijn de x, y positie en de theta hoek in verhouding tot de startpositie en de richting van de robot. Deze waarden worden opgeslagen en kunnen worden aangevraagd.

Zie appendix \ref{odometry}

\subsubsection{Range scanner}
De range scanner bevindt zich op een bepaalde hoogte boven de robot. Hij scant de omgeving horizontaal door middel van het roteren van de laser in een bepaald interval. De range scanner leest alle 181 laserwaarden uit. Deze waarden worden opgeslagen en kunnen worden aangevraagd.

Zie appendix \ref{rangescanner}

\subsubsection{Sonar}
De sonar stuurt een geluidsgolf, waardoor obstakels die op de grond liggen ook te detecteren zijn. Hij leest alle 8 sonarwaarden. Deze waarden worden opgeslagen en kunnen worden aangevraagd.

Zie appendix \ref{sonar}

\subsection{Mid-level}
De mid-level componenten verzorgen het vermijden van botsingen en het zoeken en volgen van een muur.

\subsubsection{Collision avoider}
De collision avoider kijkt alleen naar de waarden van de sonar, omdat die in tegenstelling tot de laser wel objecten op de grond kan detecteren. Als de kleinste waarde van de sonar kleiner is dan 0,315 stopt de robot met rijden. Bij deze waarde zijn objecten op de grond nog zichtbaar. Zodra deze waarde te klein wordt, kan de sonar het object niet meer zien. Tevens wordt er met behulp van de snelheid uitgerekend na hoeveel seconden de botsing plaats zal vinden als de robot door blijft rijden. Deze berekening wordt gedaan op basis van de snelheid van de wielen, en kan dus in sommige gevallen afwijken.

Zie appendix \ref{collisionavoider}

\subsubsection{Wall search}
Bij het zoeken naar een muur draait de robot eerst 360 graden om te kijken waar de dichtstbijzijnde muur is. Zodra de kleinste sensorwaarde is gevonden, roteert de robot nog een keer totdat hij de juiste positie heeft gevonden. Hij rijdt recht op de muur af totdat hij op een bepaalde afstand van de muur af staat en dan gaat hij over op wall follow.

Zie appendix \ref{wallsearch}

\subsubsection{Wall follow}
De muur wordt gevolgd die door wall search is gevonden. Als de muur zich meer aan de linkerkant van de robot bevindt, draait hij naar rechts en als de muur zich meer aan de rechterkant van de robot bevindt, draait hij naar links. De kleinste laserwaarde bevindt zich nu aan de rechter- of linkerkant. Hij blijft rechtdoor rijden als de kleinste laserwaarde niet kleiner en groter wordt dan een ingestelde waarde. Als hij te ver van de muur afwijkt, stuurt hij bij richting de muur. Als hij te dicht bij de muur komt, stuurt hij bij van de muur af. Als er geen muur meer wordt waargenomen, wordt de \verb!wall_continued()! functie binnen de wall search aangeroepen. Deze functie kijkt of er in de buurt nog een muur is te vinden. Als dit zo is, gaat hij daarheen. Als er zich in de buurt nog een andere muur bevindt, zoekt wall search naar de nieuwe dichtstbijzijnde muur. Elke keer wanneer de logica klaar is, wordt er nieuwe informatie opgevraagd van de sensormodules.%ergens is hier iets fout

Zie appendix \ref{wallfollow}

\subsection{High-level}
De high-level componenten houden bij waar de robot is geweest en kunnen hem naar een ander punt laten rijden. Dit zijn de modules die meer tijd nodig hebben dan de mid-level modules.

\subsubsection{Map maker}
De map maker maakt een kaart van de constante stroom van laser en odometry waarden die hij binnenkrijgt. Voor het maken van een kaart wordt de Simultaneous Localization And Mapping (SLAM) techniek gebruikt. De kaart heeft de vorm van een matrix.
De bibliotheek die wordt gebruikt om deze map te maken is tinySLAM. Dit is een zeer simpel algoritme dat niet meer dan 200 regels code bevat. Het enige wat het elke keer doet, is de gevonden lijnen tekenen. Dit algoritme heeft nog heel wat uitbreidingen, maar alleen de basis van dit algoritme wordt gebruikt. De originele code is geschreven in C, maar met behulp van een gevonden versie in Python en een paar aanpassingen is deze bruikbaar geworden.

Zie appendix \ref{mapmaker}

\subsubsection{Path finding}
Path finding kan alleen gebruikt worden binnen de al ontdekte gebieden en kan dus alleen een route plannen binnen een bekend domein. Hierin probeert hij een zo effici\"{e}nt mogelijk pad te vinden naar de bestemming, gebaseerd op de kaart afkomstig van de map maker. Er wordt gebruik gemaakt van het A*-algoritme om een pad te vinden tussen twee punten.

Zie appendix \ref{pathfinding}

\subsection{Libraries}
Alle modules kunnen gebruik maken van de beschikbare libraries. Ze kunnen deze libraries importeren en hun functies gebruiken.

\subsubsection{Communicator}
De comunicator library leest een bestand in dat de lokaties van de modules bevat. Via deze data maakt hij verbindingen aan met andere modules. De communicator importeert drie thread klasses en een derde klasse. De eerste thread luistert naar de gemaakte verbindingen. De tweede luistert naar een poort om te bepalen of er nieuwe verbindingen gemaakt moeten worden. De derde thread klasse maakt een verbinding aan met een andere module en onderhoud deze. De thread die luistert, handelt de berichten af volgens het communicatieprotocol. Hierin staan alle mogelijke berichten en tags die gebruikt worden bij de communicatie en er staat ook in wat hun doel is. Hierna handelt elke module zijn ontvangen data anders af.

Zie appendix \ref{communicator}

\subsubsection{Movements}
Dit is een library waarin alle bewegingen zijn gedefinieerd. Deze library wordt gebruikt voor de modules die de robot willen besturen. In de movements staan functies gedefinieerd voor het vooruit, naar links, naar rechts en achteruit rijden. Tevens is het mogelijk om naar links en rechts te roteren en de robot te laten stoppen met rijden.

Zie appendix \ref{movements}

\section{Tests}
Voor elke module is er een aparte test geschreven om er zeker van te zijn dat elke module op zichzelf goed werkt. Elke module wordt direct aan de simulator vastgezet en getest met de directe data die binnenkomen. 

\subsection{Listener}
De listener wordt getest door data te verkrijgen en deze uit te printen.

\subsection{Odometry}
De odometry wordt getest door de robot te laten rijden, 100 berichten te verkrijgen van de simulator en hiervan de odometriewaarden te printen. De odometriewaarden worden getest op geldigheid.

\subsection{Range scanner}
De range scanner wordt getest door de robot te laten rijden, 100 berichten te verkrijgen van de simulator en hiervan de 181 laserwaarden te printen. De laserwaarden worden getest op geldigheid.

\subsection{Sonar}
De sonar wordt getest door de robot te laten rijden, 100 berichten te verkrijgen en hiervan de 8 sonarwaarden te printen. De sonarwaarden worden getest op geldigheid.

\subsection{Collision avoider}
De collision avoider wordt getest door de robot vanuit verschillende startposities rond te laten rijden zonder dat er botsingen ontstaan.

\subsection{Wall search}
De wall search wordt getest door de robot vanuit verschillende startposities de dichstbijzijnde muur te laten zoeken. 

\subsection{Wall follow}
De wall follow wordt getest door de robot vanuit verschillende startposities een muur te laten volgen. Het is de bedoeling dat deze module wordt aangeroepen wanneer er al een muur is gevonden. Dan kan de robot de muur naar links en naar rechts toe volgen. Binnen deze gebruikte methode zijn stompe bochten ook mogelijk.

\subsection{Wall combo}
De wall combo is geschreven om te testen of de wall search goed werkt in samenwerking met de wall follow. Deze test simuleert
de werking in een gedistribueerd systeem.

\subsection{Map maker}
De map maker wordt getest door hem een output bestand met laser- en odometriewaarden van de wall combo te laten lezen en de kaart ervan te tekenen.

\subsection{Path finding}
De path finding wordt getest door willekeurig een tweetal punten uit een lijstje van punten te kiezen. Tussen die punten wordt vervolgens een route uitgestippeld in een 60x60 matrix. Tenslotte wordt de lijst van checkpoints van die route bepaald.

Voor path finding zijn er nog twee methoden, \verb!compress_matrix()! en\\ \verb!decompress_string()! geschreven. Die worden getest door een een string in te voeren bij \verb!decompress_string()! en vervolgens de output daarvan weer in te voeren bij \verb!compress_matrix()!. De output van \verb!compress_matrix()! zou dan hetzelfde moeten zijn als de string in het begin.

\section{Demonstratie}
De robot wordt ge\"{i}nitialiseerd op een bepaalde plaats. Hij zoekt een muur en blijft deze muur volgen. Zodra hij de opdracht krijgt om naar een punt toe te rijden, wordt path finding ingeschakeld. De map maker werkt continu de kaart bij en de collision avoider zorgt ervoor dat er geen botsingen plaatsvinden. Als hij geen nieuwe opdracht krijgt om naar een ander punt toe te rijden, gaat hij weer een muur zoeken en deze volgen.

\section{Resultaten}
Het is gelukt om alle modules op zichzelf te laten werken. Deze zijn allemaal getest en voldoen aan onze verwachtingen. De integratie ervan is echter nog niet helemaal gelukt. De integratie van zeven van de negen modules is getest. De collision avoider en path finding zijn de enige modules die niet zijn ge\"{i}ntegreerd. Alle sensormodules blijven altijd waarden ontvangen, maar de methodes van de mid-level en high-level modules blijven soms vastzitten. In deze modules wordt er gewacht totdat de data zijn verkregen die zijn verzocht, maar soms blijven ze op dit punt hangen. Ook is het gelukt om coreSLAM te gebruiken door de gevonden code aan te passen.

\section{Discussie}
De map maker zou verbeterd kunnen worden door het tekenen van de kaart in een andere thread en het ontvangen en bijwerken ervan in dezelfde thread plaats te laten vinden. Het tekenen duurt ongeveer twee seconden, want het schrijven ervan gebeurt in een apart bestand die elke keer wordt overschreven. Om dit te verbeteren zou er ook minder getekend kunnen worden. 

De path finding en map maker zouden in dezelfde module kunnen worden geplaatst. De kaart is een heel groot object, het is beter om dat niet te hoeven versturen. Als alles lokaal kan gebeuren, zou dit veel winst opleveren, bijvoorbeeld bij het comprimeren en versturen van de bestanden.

Het vastzitten van de methodes van de mid-level en high-level modules in het gedistribueerde systeem kan komen doordat een verzoek verloren gaat en de uitvoering kan daarom niet verder gaan. Een verbetering voor de communicator is het uitzoeken waarom er deadlock plaatsvindt. De berichten zouden ook in een andere vorm opgestuurd kunnen worden waardoor ze sneller gemaakt, verstuurd en ge\"{i}nterpreteerd kunnen worden.

De wall follow en de wall search hadden beter \'{e}\'{e}n module kunnen zijn. Deze twee modules hebben elkaar vaak nodig. Als er \'{e}\'{e}n module wordt gemaakt van de twee, zou dit geen problemen opleveren bij het autonoom laten rijden van de robot. In de wall search kan de logica nog iets worden verbeterd, waardoor een binnenbocht beter kan worden genomen.

De collision avoider moet nog worden ge\"{i}mplementeerd en er moet nog een tweede queue worden gemaakt waar belangrijkere commando's in komen te staan. Als laatste kan er nog een GUI gemaakt worden om de besturing van de robot gebruiksvriendelijker te maken. Python is makkelijk in gebruik, maar verliest wel performance. Het werkt langzaam en er is minder controle over de datatypes die worden gebruikt. Ook de fouthandeling is moeilijk en niet altijd vanzelfsprekend. 

De projectplanning is te strikt aangehouden. Dit zorgt ervoor dat er te weinig tijd is genomen voor de integratie en de communicatie. Dit deel van het project was toch tijdsintensiever dan vooral werd gedacht. Dit is ook te zien in het eindproduct dat nog niet helemaal werkt.

\section{Conclusie}
Het is gelukt om een modulair systeem te maken om een robot autonoom te laten rijden. Alle modules zijn op zichzelf klaar voor gebruik. Het gedistribueerde systeem werkt, maar bevat nog een aantal fouten waardoor het nog niet stabiel en snel genoeg is om de robot gedistribueerd te laten werken. Het is een leerzame maand geweest waarin er veel is geleerd over samenwerking en het maken van een groot project in Python.

\section{Bronvermelding}
\url{http://en.wikipedia.org/wiki/A*_search_algorithm}\\
\url{http://nl.wikipedia.org/wiki/A*-algoritme}\\
\url{http://www.policyalmanac.org/games/aStarTutorial.htm}\\

\newpage
\section{Appendix}
\appendix
\section*{\refstepcounter{section}\label{listener}\thesection.\quad Listener}
De listener stuurt berichten van de robot door naar de modules odometry (ODO), range scanner (RSC) en sonar (SNR). Als een datapakket incompleet is, dat wil zeggen dat er geen \verb!\n! aan het einde is, wordt er een nieuw datapakket achter geplakt.

\section*{\refstepcounter{section}\label{odometry}\thesection.\quad Odometry}
De odometry module krijgt data binnen van de listener. De data worden gesplitst in arrays op elke \verb!\r\n! die er in voorkomt. Vervolgens wordt de functie \verb!re.findall('\{[^\}]*\}|\S+', string[i])! gebruikt om elke array te splitsen in elementen die beginnen en eindigen met een accolade en overige elementen. Elke array bevat sensorinformatie als het eerste element van de array gelijk is aan \verb!SEN!. Bij berichten van het type odometry staat er op de tweede plaats in de array het element \verb!{Type Odometry}!. Er is echter tussen het eerste en tweede element het element tijd toegevoegd om te kijken of de odometriewaarden nieuw zijn of niet, waardoor het \verb!{Type Odometry}! element nu op de derde plaats in de array staat. De odometry module gebruikt de array als dit laatste element op die plaats is gevonden. De tijd van het bericht wordt samen met de odometriewaarden op de vijfde plaats in de array als een string meegegeven aan de functie \verb!odometry_module()!. De odometriewaarden komen als volgt binnen: \verb!{Pose 0.0000,0.0000,0.0000}!, oftewel x,y,theta. De \verb!odometry_module()! functie verkrijgt de drie getallen uit deze string, controleert of deze waarden geldig zijn door ze om te zetten in floats en test of de theta tussen -3.15 en 3.15 ligt. Alleen als de waarden geldig en nieuw zijn, worden ze in een string van het formaat \verb!tijd+x,y,theta! doorgestuurd naar de mid-level modules.

\section*{\refstepcounter{section}\label{rangescanner}\thesection.\quad Range scanner}
De range scanner module krijgt data binnen van de listener. De data worden gesplitst in arrays op elke \verb!\r\n! die er in voorkomt. Vervolgens wordt de functie \verb!re.findall('\{[^\}]*\}|\S+', string[i])! gebruikt om elke array te splitsen in elementen die beginnen en eindigen met een accolade en overige elementen. Elke array bevat sensorinformatie als het eerste element van de array gelijk is aan \verb!SEN!. Bij berichten van het type range scanner staat er op de tweede plaats in de array het element tijd en op de derde plaats in de array het element \verb!{Type RangeScanner}!. De range scanner module gebruikt de array als dit laatste element op die plaats is gevonden. De tijd van het bericht wordt samen met de laserwaarden op de zevende plaats in de array als een string meegegeven aan de functie \verb!range_module()!. De tijd en de laserwaarden worden gesplitst en gecontroleerd op geldigheid door ze om te zetten in floats. Alleen als de waarden geldig en nieuw zijn, worden ze in een string van het formaat \verb!tijd+x,x,...,x! doorgestuurd naar de mid-level modules.

\section*{\refstepcounter{section}\label{sonar}\thesection.\quad Sonar}
De sonar module krijgt data binnen van de listener. De data worden gesplitst in arrays op elke \verb!\r\n! die er in voorkomt. Vervolgens wordt de functie \verb!re.findall('\{[^\}]*\}|\S+', string[i])! gebruikt om elke array te splitsen in elementen die beginnen en eindigen met een accolade en overige elementen. Elke array bevat sensorinformatie als het eerste element van de array gelijk is aan \verb!SEN!. Bij berichten van het type sonar staat er op de tweede plaats in de array het element tijd en op derde plaats in de array het element \verb!{Type Sonar}!. De tijd van het bericht wordt samen met de sonarwaarden als een string meegegeven aan de functie \verb!sonar_module()!. Deze functie splitst de tijd en de sonarwaarden en controleert ze op geldigheid door ze om te zetten in floats. Alleen als de waarden geldig en nieuw zijn, worden ze in een string van het formaat \verb!tijd+1,2,3,4,5,6,7,8! doorgestuurd naar de mid-level modules.

\section*{\refstepcounter{section}\label{collisionavoider}\thesection.\quad Collision avoider}
De collision avoider module maakt gebruik van een semafoor `flag'. Zodra de flag gelijk is aan nul, zal de robot vooruit rijden en wordt \verb!getdata()! aangeroepen. Zodra het type sensor gelijk is aan sonar wordt er gekeken of de lengte van de data groter is dan 9. Hierin wordt de \verb!min_sonar_val()! functie aangeroepen met als parameter de meegegeven sonarwaarden. Hierbij wordt de \verb!string_to_float()! functie gebruikt. Elke sonarwaarde wordt omgezet in een float en deze floats worden vervolgens in een array gestopt en geretourneerd. Deze worden gesorteerd en er wordt 1 bij de eerste indexwaarde opgeteld, zodat er van 1 tot 8 wordt geteld in plaats van 0 tot 7. De \verb!min_sonar_val()! retourneert twee waardes, waarvan de eerste de minimale waarde is en de tweede de indexwaarde waar zich de minimale waarde bevindt.
Voor elke sonarwaarde wordt er gekeken of de float van elke waarde kleiner is dan de zogenaamde level, die als .25 is gegeven. Dit zal de robot genoeg ruimte geven om te kunnen roteren zonder dat deze in aanraking komt met een object. Als \'{e}\'{e}n van de twee meest rechter sonarwaarden kleiner zijn dan de meest linker sonarwaarde, wordt de robot naar links gedraaid. Zijn de twee meest linker sonarwaarden kleiner dan de meest rechter sonarwaarde, dan wordt de robot naar rechts gedraaid. Zodra de minimale waarde bij de voorste twee indexwaarden ligt en de flag gelijk is aan nul, wordt de \verb!calc_collision()! functie aangeroepen voor een mogelijke botsing. Door middel van de \verb!calc_collision()! en de \verb!calc_speed()! kan de tijd in secondes worden berekend voordat de robot in aanraking komt met een object. Als de meest rechter sonarwaarde eveneens kleiner is dan de meest linkerwaarde zal de robot naar rechts draaien, en andersom. Tenslotte wordt er een 1 geretourneerd.

\section*{\refstepcounter{section}\label{wallsearch}\thesection.\quad Wall search}
De wall search wacht totdat hij wordt aangeroepen door de wall follow. Wanneer dat gebeurt, krijgt hij een bericht van de wall follow van het type NEX. Zodra hij dit heeft gekregen, gaat hij naar de \verb!wall_continued()! methode. Hier vraagt hij data op van de range scanner. Als de minimale laserwaarde kleiner of gelijk is aan 0.62, dan stuurt de robot naar de kant toe waar de muur is en dan wordt \verb!wallfollow()! weer aangeroepen. Als dit niet geldt, gaat de robot eerst een klein stukje rijden in de richting waar hij de muur was verloren om te kijken of de muur een bocht maakt. Indien hij dan nog steeds geen muur vindt, dan draait hij 360 graden om een muur te zoeken. Na het vinden van deze muur draait de robot er naartoe, rijdt er recht op af en stopt ervoor met een threshold van 0.4. Hierna stuurt hij een bericht met NEX naar de \verb!wallfollow()! en wacht totdat hij weer wordt aangeroepen.

\section*{\refstepcounter{section}\label{wallfollow}\thesection.\quad Wall follow} De wall follow haalt elke iteratie laserwaarden op en gaat daarmee aan de slag. In de wall follow wordt \verb!min_laser_val()! gebruikt om de kleinste
laserwaarde te vinden en op welke index die waarde zit. Er is een semafoor flag om de threshold te bepalen van de afstand die de robot van de muur af mag staan. Deze wordt gebruikt, omdat er bij een gevonden muur met wat ruimte omheen mag worden gereden. Het is immers bekend dat er een muur wordt gevolgd, maar er is toch een threshold nodig om te kunnen bepalen wanneer de muur ophoudt. De logica begint met het controleren of de voorste laserwaarden te klein zijn. Dit zou betekenen dat er zich een muur voor de robot bevindt. Bij het volgen van een muur wordt er bepaald of de kleinste laserwaarde links of rechts van het midden zit. Hierna draait de robot zich weg van de muur. Hierna wordt er bepaald of de robot te dicht bij de muur zit of niet. Als dit zo is, wordt er eerst gekeken of er zich aan de andere kant ook een muur bevindt. In dit geval blijft de robot rechtdoor rijden om door de doorgang te rijden en anders wordt er bijgestuurd. Daarna wordt er gekeken of de robot te ver van de muur af rijdt en wordt er bijgestuurd richting de muur. Als dit allemaal niet waar is, wordt \verb!wallfollow()! aangeroepen. Deze controleert eerst of de robot ook echt een muur aan het volgen is en aan welke kant die muur van de robot zit. Vervolgens krijgt de robot het commando om rechtdoor te rijden. Wanneer er van de threshold wordt afgeweken, wordt er overgegaan op de \verb!wallsearch!. Deze zoekt dan weer de nieuwe dichtstbijzijnde muur. 

\section*{\refstepcounter{section}\label{mapmaker}\thesection.\quad Map maker}
De map maker maakt gebruik van tinySLAM, dit is een library voor SLAM die te vinden is op \url{http://www.openslam.org}.
%\cite{openSLAM,CoreSLAM:article}.
Hier is een Python versie %\cite{CoreSLAM:python} 
van gevonden. Deze Python library werkt als volgt. Elke keer dat de kaart bijgewerkt moet worden, wordt de methode \verb!makeMap()! aangeroepen. De laserwaarden kunnen direct meegegeven worden aan deze methode, maar de positie van de
odometry moet eerst worden getransformeerd naar het midden van het plaatje. Ook wordt de theta van de odometry omgezet van radialen in graden. In de \verb!makeMap()! methode wordt elke laserstraal een beetje aangepast en daarna wordt de \verb!ts_map-update()! aangeroepen die vervolgens alle stralen in de kaart tekent. Hierna kan op elk moment een kaart worden getekend met de methode \verb!drawMap()!. Deze methode krijgt een kaart mee om te tekenen. Binnen de methode worden alle punten op de kaart afgegaan en wordt er een grijze, witte of zwarte pixel getekend, afhankelijk van wat er in de kaart staat. Deze pixels worden geschreven naar een .ppm bestand, want de libraries die standaard worden gebruikt om te kunnen tekenen waren niet aanwezig op de gebruikte computers.
\section*{\refstepcounter{section}\label{pathfinding}\thesection.\quad Path finding}
De module path finding bevat de klasse \verb!node!. Binnen die klasse zijn er enkele methoden aanwezig die gebruikt worden voor het cre\"{e}ren van een node object. \verb!__init__()! wordt toegepast voor de initialisatie, \verb!manhattan()! voor het berekenen van de afstand tussen een punt en het eindpunt, \verb!new_pr()! bepaalt de prioriteit van een node, \verb!move()! zorgt ervoor dat de prioriteit gegeven wordt aan een node die recht in plaats van diagonaal voor een andere node staat. In \verb!a_star_search()! wordt het daadwerkelijke A*-algoritme uitgevoerd. Allereerst wordt er een node gemaakt voor het startpunt. Die wordt dan gemarkeerd in de lijst van open nodes. Vervolgens wordt de zoektocht uitgevoerd. De node met de hoogste prioriteit wordt er steeds uitgehaald en gemarkeerd in de lijst van closed nodes. 
Verder wordt er gebruik gemaakt van child nodes in de zoektocht naar een geschikte route. Indien het eindpunt al bereikt is, dan wordt de route samengesteld en geretourneerd. \verb!route_on_map()! wordt gebruikt om de route uit \verb!a_star_search()! in een kaart (matrix) te tekenen. \verb!show_map()! is de methode die ervoor zorgt dat de kaart met de route op een duidelijke manier weergegeven wordt.
Om er achter te komen wat de checkpoints zijn die vereist zijn om de robot van punt A naar punt B te laten voortbewegen, is er \verb!read_map()!. Het startpunt van de route wordt beschouwd als eerste checkpoint en het eindpunt als laatste checkpoint. Om een lijst van checkpoints te berekenen, moeten alle punten uit de route in de kaart worden afgegaan. Om van een punt naar een ander punt te gaan, wordt er rondom het punt gekeken of er zich andere punten van de route bevinden. Bij punten die zich in een diagonale richting bevinden van een punt, moet er eerst worden gecontroleerd of er toch geen punten aanwezig zijn in de verticale of horizontale richting. Als dat zo is, moeten de punten in de verticale of horizontale richting voorrang krijgen. Bij punten die zich in verticale of horizontale richting bevinden, hoeft er dan niet meer extra gecontroleerd worden op andere punten. Als het eindpunt bereikt is, wordt de lijst van checkpoints geretourneerd.

De data die de path finding module moeten krijgen, zou afkomstig moeten zijn van de map maker. De map maker zou zijn data in de vorm van een string naar de path finding verzenden. Een compressiemethode \verb!compress_matrix()! is vereist om een matrix om te zetten naar een string. De data die de path finding ontvangt, wordt dan omgezet door de methode \verb!decompress_string()!.

\section*{\refstepcounter{section}\label{protocol}\thesection.\quad Communicatieprotocol}
\begin{verbatim}
TAG:
REQ: data sturen
RCV: data ontvangen
CMD: movement commando's
NEX: go to the next module

data TAG:
SNR: sonar
ODO: odometry
RSC: rangescanner
MAP: map

module TAG:
ODO: Odometry
RSC: Rangescanner
SNR: Sonar
WFW: Wall Follow
CAV: Collision Avoider
WSC: Wall Search
MAP: Map Maker
PLA: Route Planner
LIS: Listener

dividers:
#: eindetransmissie
!: transmissie divider

Vorm:
REQ:
REQ!"own module TAG"# 
example: REQ!WFW# this send to a sensor module will return the data of that module.
RCV!"data TAG"!"data"# 
example: RCV!SNR!x,x,x,x,x,x,x,x# this will send the data to a module.
CMD!"commando"# CMD!drive# will send a drive command.
NEX!"side"# example: NEX!1# 1 if wall is on the right side.


data:
SNR:
naar sensor module:
{Name F1 Range "x"} {Name F2 Range "x"} {Name F3 Range "x"} {Name F4 Range "x"} 
{Name F5 Range "x"} {Name F6 Range "x"} {Name F7 Range "x"} {Name F8 Range "x"}
uit sensormodule:
{Time}+x,x,x,x,x,x,x,x

RSC:
naar sensor module:
{Range "x","x",...,"x"}
uit sensormodule:
{Time}+x,x,x,x,x,x,x,x,x,x,....,x,x,x

ODO:
naar sensor module:
{Pose x,y,theta}
uit sensormodule:
{Time}+x,y,theta

MAP:
"# of characters""type"_"# of characters""type"_...._"# of characters""type"
\end{verbatim}

\section*{\refstepcounter{section}\label{communicator}\thesection.\quad Communicator}
\subsection*{Gebruik}
Elke module maakt via deze library verbindingen aan. Dit doen de modules door eerst een \verb!config_reader! aan te maken en daarna starten ze de \verb!accept_thread! op. Deze thread moet op \verb!setDaemon! gezet worden, zodat hij sluit wanneer het hoofdprogramma sluit.
\begin{verbatim}{}
configreader = config_reader()
print("config reader gestart")
accept_thread = acceptor(running, list, "LIS", configreader.addresses)
accept_thread.setDaemon(True)
accept_thread.start()
\end{verbatim}
Hierna kunnen de verbindingen worden opgezet. Dit gebeurt op de volgende manier.
\begin{verbatim}{}
sonar = connection(running, "SNR", configreader, list)
sonar.setDaemon(True)
sonar.start()
\end{verbatim}
Deze code zet een verbinding op met de sonar module. \verb!sonar.send_data(message)! wordt gebruikt om iets te versturen over de gemaakte verbinding. Deze verbinding zal zelf kijken of de verbinding het nog doet en indien hij niet meer werkt, zal hij opnieuw proberen te verbinden met de module.
\subsection*{Werking}
De \verb!config_reader! leest eerst het \verb!config.cfg! bestand uit in een array. Deze wordt dan gesplitst en globaal in de klasse gestopt met de naam \verb!addresses!.
\begin{verbatim}
f = open('config.cfg')
addresses = []
config = f.readlines()
for i in range(len(config)):
    config[i] = config[i].strip()
    addresses.append(config[i].split(' '))
self.addresses = addresses
\end{verbatim}
De andere methode in de \verb!config_reader! geeft een socket terug waarover de gevraagde verbinding is gemaakt. Hij kijkt eerst in de de meegekregen lijst of de verbinding die is opgevraagd al is gemaakt. Hiervoor heeft hij het IP-adres nodig, deze haalt hij uit de global addresses. Indien de verbinding al is gemaakt, geeft hij de socket van die verbinding terug. Deze wordt gelezen uit de lijst.
\begin{verbatim}
for i in range(len(self.addresses)):
    if self.addresses[i][0] == module:
        address = self.addresses[i]
        ip = socket.gethostbyname_ex(address[1])
for i in range(len(list)):
    if list[i][1][0] == ip[2][0]:
        return list[i][0]
\end{verbatim}
De acceptor maakt eerst globale variabelen aan, waaronder de thread waar vandaan hij luistert naar verbindingen. Een deel van deze variabelen wordt meegegeven.
\begin{verbatim}
def __init__ (self, running, list, module, addresses):
    threading.Thread.__init__(self)
    self.running = running
    self.list = list
    self.module = module
    self.addresses = addresses
    # array with the received data:
    # [0]: sonar
    # [1]: odometry
    # [2]: rangescanner
    # [3]: map
    # [4]: command
    # [5]: nex        
    self.memory = ["","","","","",""]
    self.waiting_for_data = 0
    self.request_data = []
    communicationthread = communication(self.list, self.running, 
    self.memory, self.waiting_for_data, self.request_data)
    communicationthread.setDaemon(True)
    communicationthread.start()
    self.communicationthread = communicationthread
\end{verbatim}
De \verb!memory! is een array waarin de ontvangen data worden opgeslagen totdat deze worden verwerkt.
De twee methodes daarna zorgen ervoor dat de modules kunnen wachten op data. Deze methoden refereren naar methodes in de luister thread.
\begin{verbatim}
def set_wait(self, number):
    self.communicationthread.set_wait(number)
def get_wait(self):
    return self.communicationthread.get_wait()
\end{verbatim}
De main van de thread zorgt ervoor dat er verbindingen kunnen worden gemaakt met de module waar deze thread in is opgestart. Hij kijkt in de addresses variabele op welke IP en port hij moet luisteren. Daarna begint hij met het luisteren op deze socket. Vervolgens gaat hij in een loop waarin hij blijft wachten totdat er iemand wil verbinden met deze module. Als er een verbinding binnenkomt, zet hij deze verbinding in de lijst.
\begin{verbatim}
for i in range(len(self.addresses)):
    if self.addresses[i][0] == self.module:
        TCP_IP = self.addresses[i][1]
        TCP_PORT = int(self.addresses[i][2])
BUFFER_SIZE = 1024
try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind((TCP_IP, TCP_PORT))
    s.listen(0)
    s.setblocking(0)
except socket.error:
    print 'kip'
    self.running = 0
    s.close()
    self.communicationthread.join()
    sys.exit()
while self.running:
    try:
        connection = s.accept()
        connection[0].setblocking(0)
        print 'voor append'
        self.list.append(connection)
        print 'na append'
    except(socket.error):
	      if self.running == 0:
	          break
\end{verbatim}
De communication thread is de thread die luistert naar de verbindingen om te kijken of ze data ontvangen. Als eerste maakt hij globale variabelen aan die hij mee heeft gekregen. Dit zorgt ervoor dat ze gelinkt zijn met de variabelen in de acceptor thread.
\begin{verbatim}
def __init__(self, list, running, memory, waiting_for_data, request_data):
    threading.Thread.__init__(self)
    self.list = list
    self.running = running
    self.memory = memory
    self.waiting_for_data = waiting_for_data
    self.request_data = request_data
\end{verbatim}
Er wordt gerefereerd naar twee methodes in de acceptor thread. %En een derde methode die connecties aan de lijst zet. misschien methode weghalen
\begin{verbatim}
    def set_wait(self, number):
        self.waiting_for_data += number
    def get_wait(self):
        return self.waiting_for_data
\end{verbatim}
De main van deze thread handelt de berichten af volgens het protocol. Elk ontvangen bericht wordt anders afgehandeld door middel van if else statements. Ook zorgt deze thread ervoor dat een verbinding die niet meer werkt uit de lijst wordt verwijderd.
\begin{verbatim}
def run(self):
    BUFFER_SIZE = 1024
    data = ""
    data_incomplete = 0
    while self.running:
        if(len(self.list) == 0):
            time.sleep(0.1)
            for i in range(len(self.list)):
            while 1:
                try:
                    self.list[i][0].setblocking(0)
                    data = self.list[i][0].recv(BUFFER_SIZE)
                        if not data:
                        self.list.pop(i)
                        print i
                        print "pop van list"
                        break
                    if data_incomplete:
                        datatemp += data
                        data_incomplete = 0
                        data = datatemp
                    if(len(data) > 1):
                        if data[len(data)-1] != '#':
                            datatemp = data
                            data_incomplete = 1
                            continue
                    else:
                        continue
                    messagesplit = data.split("#")
                    for j in range(len(messagesplit)):
                        datasplit = messagesplit[j].split("!")
                        if len(datasplit) < 1:
                            continue
                        if(datasplit[0] == "REQ"):
                            self.request_data.append(datasplit[1])
                            data = " "
                            datasplit = []
                        elif(datasplit[0] == "CMD"):
                            self.memory[4] = datasplit[1]
                            data = " "
                            datasplit = []
                        elif(datasplit[0] == "RCV"):
                            if(datasplit[1] == "SNR"):
                                self.memory[0] = datasplit[2]
                                if(self.waiting_for_data > 0):
                                    self.waiting_for_data -= 1
                                data = " "
                                datasplit = []
                            elif(datasplit[1] == "ODO"):
                                self.memory[1] = datasplit[2]
                                if(self.waiting_for_data > 0):
                                    self.waiting_for_data -= 1
                                data = " "
                                datasplit = []
                            elif(datasplit[1] == "RSC"):
                                self.memory[2] = datasplit[2]
                                if(self.waiting_for_data > 0):
                                    self.waiting_for_data -= 1
                                data = " "
                                datasplit = []
                            elif(datasplit[1] == "MAP"):
                                self.memory[3] = datasplit[2]
                                if(self.waiting_for_data > 0):
                                    self.waiting_for_data -= 1
                                data = " "
                                datasplit = []
                        elif(datasplit[0] == "NEX"):
                            self.memory[5] = datasplit[1]
                            data = " "
                            datasplit = []                                    
                except(socket.error):
                    if self.running == 0:
                        break
                except(IndexError):
                    break
                break
\end{verbatim}
De laatste thread klasse in deze library is de connection. Deze begint ook met globale variabelen te initialiseren, deze variabelen worden meegegeven wanneer hij wordt aangemaakt.
\begin{verbatim}
def __init__ (self, running, module, configreader, list):
    threading.Thread.__init__(self)
    self.running = running
    self.module = module
    self.list = list
    self.configreader = configreader
    self.socket = self.configreader.connection(self.list, self.module)
    self.connected = 1
\end{verbatim}
De methode van deze klasse stuurt meegekregen data over de socket van de klasse.
\begin{verbatim}
def send_data(self, data):
    if self.connected:
        self.socket.send(data)
\end{verbatim}
De main onderhoudt de verbinding op een soortgelijke manier als de \verb!config_reader! een al gemaakte connectie teruggeeft. Als hij al gemaakt is, dan probeert hij opnieuw te verbinden en zet hij zijn connected flag op 0 voor not connected.
\begin{verbatim}
def run(self):
    while self.running:
        for i in range(len(self.configreader.addresses)):
            if self.configreader.addresses[i][0] == self.module:
                address = self.configreader.addresses[i]
                ip = socket.gethostbyname_ex(address[1])
        for i in range(len(self.list)):
            if self.list[i][1][0] == ip[2][0]:
                self.connected = 1
                break
            else:
                self.connected = 0
        if not self.connected:
            self.socket = self.configreader.connection(self.list, self.module)
\end{verbatim}

\section*{\refstepcounter{section}\label{movements}\thesection.\quad Movements}
Elke module kan een commando type aanroepen in de movements library via de \verb!handle_movements()! functie. Hierin staan alle mogelijke bewegingen die behandeld kunnen worden.  
\verb!go_drive()! zorgt ervoor dat de robot vooruit en achteruit kan rijden, bochten en rotaties kan maken. Hierbij wordt voor zowel het linker- als het rechterwiel dezelfde parameter meegegeven. 
Bij \verb!go_rotate_right()! en \verb!go_rotate_left()! wordt een rotatie uitgevoerd om de as van de robot. De meegegeven parameter bepaalt de snelheid van de rotatie. 
Om naar rechts te draaien moet de parameter van het rechterwiel groter zijn dan die van het linkerwiel en omgekeerd. De functies \verb!go_right()! en \verb!go_left()! worden hierbij gebruikt.
De robot remt bij het gebruik van \verb!go_brake()!, hierbij staan beide wielen op een snelheid van 0.
Door de wielen een gelijke negatieve waarde mee te geven in de functie \verb!go_reverse()!, zal de robot achteruit rijden.

%\bibliographystyle{plain}

\end{document}