\documentclass[a4paper,10pt]{article}
\usepackage{graphicx}
\usepackage[dutch]{babel}

\title{Software Engineering en Gedistribueerde Applicaties \\[10pt]Verslag\\[25pt]Team F.A.C.H.T.}
\author{\\Chris Bovenschen, Harm Dermois, \\Alexandra Moraga Pizarro, Tamara Ockhuijsen en Fredo Tan \\[10pt]6104096, 0527963, 6129544, 6060374, 6132421 \\[25pt]Universiteit van Amsterdam}
\begin{document}
\maketitle

\newpage
\tableofcontents

\newpage
\section{Inleiding}
Dit verslag beschrijft het ontwerpen, implementeren en testen van een gedistribueerde robotapplicatie. De robot die hiervoor wordt gebruikt is de gesimuleerde P2DX, deze heeft twee aangedreven wielen en een zwenkwiel. Het platform voor de robotsimulatie is USARSim. Het doel is om met behulp van de sensoren op de robot in een vrij volle ruimte een pad langs een wand te rijden, botsingen te vermijden, zonodig een wand op te zoeken, uit doodlopende stukken te ontsnappen, bijhouden waar hij is en welk pad hij heeft gevolgd en de omgeving in kaart te brengen. 

Het project is op te delen in verschillende fases. Aan het begin is er nagedacht over een ontwerp met een model, een planning en een specificatie van het eindproduct. Hieruit is een voorlopig werkplan ontstaan. In het definitieve werkplan is een uitgebreidere beschrijving van de realisatie van verschillende componenten met bijbehorende tests te vinden samen met de eerste inleverbare versie van de code. Het grootste deel van de tijd heeft gezeten in de implementatie en tests. Als laatst zijn de componenten ge\"{i}ntegreerd tot een geheel, getest en geoptimaliseerd.

Dit verslag behandelt eerst de implementatie van de componenten met de bijbehorende tests en de opzet van het experiment. Daarna worden de resultaten besproken en hieruit volgt een conclusie.

\newpage

\section{Implementatie}
De modules zijn verdeeld in low-level, sensor, mid-level en high-level componenten. De listener is een low-level component, de sonar, laser en odometry zijn sensormodules, de wall search, wall follow en collision avoider zijn mid-level componenten en de map maker en path finding zijn high-level componenten. De movements en communicator zijn libraries die door andere modules kunnen worden gebruikt. 

De listener is verbonden met de server via een TCP-verbinding en stuurt de data in een geldig formaat door naar de sensormodules. De sensormodules halen de juiste waarden uit de data en sturen deze door naar de mid-level modules en op aanvraag naar de map maker en path finding. Berekende kaarten van de map maker kunnen worden gebruikt voor de path finding. Path finding gebruikt de movements library om het pad te kunnen volgen. Als de robot aan het rijden is, staat de collision avoider te alle tijden aan.

\subsection{Low-level}
De low-level component verkrijgt rechtstreeks data van de robot, haalt ze uit elkaar en stuurt de data door naar de juiste module.

\subsubsection{Listener}
De listener zit direct aan de server vast. Hij haalt informatie binnen die de robot verstuurt en stuurt ook commando's naar de robot toe. De binnenkomende data worden gecontroleerd op geldigheid en in het juiste formaat gestuurd naar de bijbehorende sensormodules.

\subsection{Sensormodules}
De sensormodules ontvangen data van de listener. Ze verkrijgen de sensorwaarden uit de data en sturen ze door naar de mid-level modules. De sensormodules kunnen door de high-level modules worden aangeroepen voor de meest recente data. Zodra er ongeldige data binnenkomen, wordt de robot gestopt.

\subsubsection{Odometry}
Odometry haalt de drie waarden op die nodig zijn voor de bepaling van de positie van de robot. Dit zijn de x, y positie en de theta hoek in verhouding tot de startpositie en de richting van de robot. Deze waarden worden doorgestuurd naar de mid-level modules.

\subsubsection{Range scanner}
De range scanner leest alle 181 laserwaarden uit en stuurt ze door naar de mid-level modules. 

\subsubsection{Sonar}
De sonar leest alle 8 sonarwaarden uit en stuurt ze door naar de mid-level modules.

\subsection{Mid-level}
De mid-level componenten verzorgen het vermijden van botsingen en het zoeken en volgen van een muur.

\subsubsection{Collision avoider}
De collision avoider kijkt alleen naar de waarden van de sonar, omdat de sonar een geluidsgolf stuurt, kan het ook dingen die op de grond liggen zien. Als de kleinste waarde van de sonar kleiner is dan 0,315 stopt de robot met rijden. Tevens wordt er met behulp van de snelheid uitgerekend na hoeveel seconden de botsing plaats zal vinden als de robot door blijft rijden. Dit wordt gedaan op basis van de snelheid van de wielen dus kan in sommige gevallen niet helemaal waar zijn.

\subsubsection{Wall follow}
De muur wordt gevolgd die door wall search is gevonden. Als de muur zich meer aan de linkerkant van de robot bevindt, draait hij naar rechts en als de muur zich meer aan de rechterkant van de robot bevindt, draait hij naar links. De kleinste laserwaarde bevindt zich nu aan de rechter- of linkerkant. Hij blijft rechtdoor rijden als de kleinste laserwaarde niet kleiner en groter wordt dan een ingestelde waarde. Als hij te ver van de muur afwijkt, stuurt hij bij richting de muur. Als hij te dicht bij de muur komt, stuurt hij bij van de muur af. Als er geen muur meer wordt waargenomen, gaat het eerst naar een continued wallfollow methode binnen de wallsearch. Deze kijkt of er ergens dicht bij nog een muur is. Als dit zo is gaat hij daar heen. Als niets dichtbij is zoekt wall search de nieuwe dichtstbijzijnde muur. Elke keer wanneer hij klaar is met de logica vraagt hij nieuwe informatie op van de sensoren modules.

\subsubsection{Wall search}
Bij het zoeken naar een muur draait de robot eerst 360 graden om te kijken waar de dichtstbijzijnde muur is. Zodra de kleinste sensorwaarde is gevonden, roteert de robot nog een keer totdat hij in de juiste positie staat. Hij rijdt recht op de muur af totdat hij op een bepaalde afstand van de muur af staat en dan gaat hij over op wall follow.

\subsection{High-level}
De high-level componenten houden bij waar de robot is geweest en kunnen hem naar een ander punt laten rijden. Dit zijn de modules ide meer tijd nodig hebben dan de mid-level modules.

\subsubsection{Map maker}
De map maker maakt een kaart van de constante stroom van laser en odometry waarden die hij binnenkrijgt. Voor het maken van een kaart wordt de Simultaneous Localization And Mapping (SLAM) techniek gebruikt. De kaart heeft de vorm van een matrix.
De bibliotheek die we gebruiken om deze map te maken is tinySLAM. Dit is een zeer simpel algoritme om dit te doen. Het is niet meer dan 200 regels code. Het enige wat het doet is elke keer de gevonden lijnen tekenen. Dit algoritme heeft nog heel wat uitbreidingen, maar wij hebben alleen de basis van dit algoritme gebruikt. De originele code is geschreven in C maar wij hebben een versie in python gevonden die wij met een paar aanpassingen konden gebruiken. ref

\subsubsection{Path finding}
Path finding kan alleen gebruikt worden binnen het al ontdekte delen en kan dus alleen een route plannen binnen een bekend domein. Hierin probeert hij een zo kort mogelijk pad te vinden naar de bestemming. Er wordt gebruik gemaakt van het A ster zoekalgoritme om het effici\"{e}ntste pad te vinden tussen twee punten.

\subsection{Libraries}
Alle modules kunnen gebruik maken van de beschikbare libraries. Ze kunnen deze libraries importeren en hun functies gebruiken.

\subsubsection{Communicator}
De communicator zorgt voor de communicatie tussen de modules en maakt een ge\"{i}ntegreerd geheel van de losse modules. De communicatie verloopt via een communicatieprotocol.

\subsubsection{Movements}
Dit is een library waarin alle bewegingen zijn gedefinieerd. Deze library wordt gebruikt voor de modules die de robot willen besturen.

\section{Tests}
Voor elke module is er een aparte test geschreven om er zeker van te zijn dat elke module op zichzelf goed werkt. Elke module wordt direct aan de simulator vastgezet en getest met de directe data die binnenkomen. 

\subsection{Listener}
De listener wordt getest door data te verkrijgen en deze per type bericht in een nieuwe array uit te printen.

\subsection{Odometry}
De odometry wordt getest door 100 regels data te verkrijgen van de simulator en hiervan de odometriewaarden te printen.

\subsection{Range scanner}
De range scanner wordt getest door 100 regels data te verkrijgen van de simulator en hiervan de 181 laserwaarden te printen.

\subsection{Sonar}
De sonar wordt getest door 100 regels data te verkrijgen en  hiervan de 8 sonarwaarden te printen

\subsection{Collision avoider}
De collision avoider wordt getest door de robot vanuit verschillende startposities rond te laten rijden zonder dat er botsingen ontstaan.

\subsection{Wall combo}
De wall combo is geschreven om te testen of de wall search goed werkt in samenwerking met de wall follow. Deze test simuleert
hoe het zou werken wanneeer het in een gedistribueerde systeem zou werken.

\subsection{Wall follow}
De wall follow wordt getest door de robot op verschillende startposities een muur te laten volgen. Het is de bedoeling dat deze
module wordt aangeroepen wanneer er een muur gevonden is. Dan kan het een muur beide kanten op volgen. Binnen deze methode kan het ook zwakke bochten maken.

\subsection{Wall search}
De wall search wordt getest door de robot op verschillende startposities de dichstbijzijnde muur te zoeken. 

\subsection{Map maker}
De map maker is getest door het een output file van de wall combo te lezen en dat te tekenen. 

\subsection{Path finding}

\section{Experiment}
De robot wordt geïnitialiseerd op een bepaalde plaats. Hij zoekt een muur en blijft deze muur volgen. Zodra hij de opdracht krijgt om naar een punt toe te rijden, wordt path finding ingeschakeld. De map maker werkt continu de kaart bij en de collision avoider zorgt ervoor dat er geen botsingen plaatsvinden. Als hij geen nieuwe opdracht krijgt om naar een ander punt toe te rijden, gaat hij weer een muur zoeken en deze volgen.

\end{document}
